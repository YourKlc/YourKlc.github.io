---
title: 数位DP
date: 2025-03-04 19:17:00 +0800
categories: [Algorithm, DP] #一级目录, 二级目录
tags: [csharp, algorithm, dp, digital]    # TAG names should always be lowercase

toc: true #右侧内容位置是否显示, 默认值在_config.yml

comments: false #评论是否开启

math: false #数学符号是否加载

mermaid: true #mermaid是否开启.

pin: true #是否置顶

#![img-description](/path/to/image)
#_Image Caption_ 图片的说明

#![Desktop View](/assets/img/sample/mockup.png){: width="700" height="400" } 设置图片宽高

#```
#{: file="DesignMode" }   #设置代码块标题
---

<style>
hr{
  height: 4px;
  width: 100%;
  margin: 0,0,0,0;
  margin - left : auto;
  margin - right : auto;
  opacity: 100%;
  border-top: 1px dashed #ffff0080 !important;
  border-bottom: 1px dashed #00ff0080 !important;
  border-radius: 0px; 
}
</style>

## 排序

数位DP把一个数字按每一位拆开进行DP<br>
对于位数比较多的数,在针对每一位的数字进行统计时,会发现有很多重复部分,比如
1000到1999 和 2000到2999的后三位都是从0~999,所以可以把这些重复部分先存起来,
节省运算次数,

>如[P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)  <br>
>$$\text{问题:给定两个正整数 a 和 b，求在 [a,b] 中的所有整数中，每个数码(digit)各出现了多少次。}\\
 \left(\text{对于 100\% 的数据，保证}  1≤a≤b≤10^{12} \right) $$
 
用C#实现


___

## C#实现

``` c#
using System;
using System.Linq;

public class LGEndClass
{
    public static int Main()
    {
        string input = Console.ReadLine();
        long[] nums = input.Split(" ", StringSplitOptions.RemoveEmptyEntries)
                       .Select(long.Parse)
                       .ToArray();
        long ia = nums[0], ib = nums[1];
        int N = 10;
        //dp[i,j] 含义, 前i位数包含j的数有多少个 
        long[,] dp = new long[13, N];
        long[] mi = new long[13];
        mi[0] = 1;
        for (int i = 1; i < 13; i++)
        {
            for (int j = 0; j < N; j++)
            {
                //前者由前i-1位(1)+首位非j(9)的数贡献,后者为首位为j的贡献(此时任何情况都包含j)
                dp[i, j] = dp[i - 1, j] * N + mi[i - 1];
            }
            mi[i] = mi[i - 1] * N;
        }
        // fc 计算 0~num 中出现 0~9 数字的个数，存到 res
        Action<string, long[]> fc = (string num, long[] res) =>
        {
            long tmp = long.Parse(num); // 初始化 tmp
            for (int i = 0; i < num.Length; i++) // 从最高位开始遍历
            {
                int q = num[i] - '0'; // 当前位的数字值
                int pos = num.Length - i - 1; // 当前位的权重位置

                for (int j = 0; j < N; j++) // 当前位为 0~q-1，低位数码总出现次数
                {
                    res[j] += dp[pos, j] * q;
                }

                for (int j = 0; j < q; j++) // 当前位为 0~q-1 时，当前位数码的贡献
                {
                    res[j] += mi[pos];
                }

                tmp -= mi[pos] * q; // 更新 tmp
                res[q] += tmp + 1;
                res[0] -= mi[pos]; // 修正前导零
            }
        };
        long[] ansa = new long[N];
        long[] ansb = new long[N];
        fc((ia - 1).ToString(), ansa);
        fc(ib.ToString(), ansb);

        for (int i = 0; i < 10; i++)
        {
            Console.Write($"{ansb[i] - ansa[i]} ");
        }
        return 0;
    }
}
```
{: file="C#实现" }

