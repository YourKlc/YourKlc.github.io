---
title: C#并发
date: 2023-10-26 18:05:00 +0800
categories: [Language, CSharp] #一级目录, 二级目录
tags: [CSharp, Thread, parallel, asynchronous]     # TAG names should always be lowercase

toc: true #右侧内容位置是否显示, 默认值在_config.yml

comments: false #评论是否开启

math: false #数学符号是否加载

mermaid: true #mermaid是否开启.

pin: true #是否置顶

#![img-description](/path/to/image)
#_Image Caption_ 图片的说明

#![Desktop View](/assets/img/sample/mockup.png){: width="700" height="400" } 设置图片宽高

#```
#{: file="DesignMode" }   #设置代码块标题

---

<style>
hr{
  height: 4px;
  width: 100%;
  margin: 0,0,0,0;
  margin - left : auto;
  margin - right : auto;
  opacity: 100%;
  border-top: 1px dashed #ffff0080 !important;
  border-bottom: 1px dashed #00ff0080 !important;
  border-radius: 0px;
}
</style>
# 并发
并发可以通过多线程(线程池)、异步编程、响应式编程实现
多线程包括并行(把正在执行的大量的任务分割成小块，分配给多个同时运行的线程)


## 异步编程
使用两个关键字: async和await
async加在方法声明上, 作用是使方法内的await关键字生效, 如果async方法有返回值, 应该返回Task<T>, 如果没有返回值, 应该返回Task, 
await用来异步等待, 使得方法可异步等待另一个Task执行完成后再继续执行
有些细节需要注意:
1.一定要避免使用Task.Wait 或 Task<T>.Result 方法，因为它们会导致死锁
2.一个async方法第一个同步程序块在调用这个方法的线程中运行, 但其他同步块运行线程需要根据情况决定
  每个方法会试图在原始的上下文中恢复运行, 如果在UI线程中调用, 则在此UI线程中执行, 如果在线程池中调用, 则在线程池线程上运行
  要避免这种错误行为, 可以在await中调用ConfigAwait方法, 将continueOnCapturedContext设置为false

``` c#    
    
    public static async void DoSomething()
    {
        Console.WriteLine(10);
        await DoTask(); //加await则异步等待, 不加则直接往下运行
        Console.WriteLine(20);
    }
    static async Task DoTask() 
    {
        int timer = 10;
        while(timer-->=0)
        {
            Console.WriteLine("Task:" + timer);
            await Task.Delay(TimeSpan.FromSeconds(1));
        } 
    }

```
{: file="异步" }
